<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Decentralized Media Hub</title>
  <!-- Favicon - Minimalist play icon -->
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><circle cx='50' cy='50' r='45' fill='%23333'/><polygon points='35,25 75,50 35,75' fill='%23eee'/></svg>">
  <!-- PeerJS Library for WebRTC -->
  <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
  <style>
    /* === Global Styles & Resets === */
    :root {
      --primary-bg: #1a1a1d;
      --secondary-bg: #2c2c34;
      --tertiary-bg: #44444f;
      --accent-color: #00aaff;
      --text-color: #e0e0e0;
      --text-muted: #a0a0a0;
      --success-color: #4caf50;
      --error-color: #f44336;
      --border-radius: 8px;
      --transition-speed: 0.3s;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body {
      height: 100%;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
      background-color: var(--primary-bg);
      color: var(--text-color);
      font-size: 16px;
      line-height: 1.6;
      overflow: hidden;
    }
    /* === Utility Classes === */
    .hidden { display: none !important; }
    .text-center { text-align: center; }
    .error-message { color: var(--error-color); font-size: 0.9em; margin-top: 5px; }
    .success-message { color: var(--success-color); font-size: 0.9em; margin-top: 5px; }
    .button {
      background-color: var(--accent-color);
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: var(--border-radius);
      cursor: pointer;
      font-size: 1em;
      transition: background-color var(--transition-speed) ease, transform var(--transition-speed) ease;
      display: inline-block;
      text-align: center;
    }
    .button:hover { background-color: #0088cc; transform: translateY(-2px); }
    .button:active { transform: translateY(0); }
    .button.secondary { background-color: var(--tertiary-bg); }
    .button.secondary:hover { background-color: #555566; }
    input[type="text"], input[type="password"], input[type="file"] {
      padding: 10px;
      border: 1px solid var(--tertiary-bg);
      background-color: var(--secondary-bg);
      color: var(--text-color);
      border-radius: var(--border-radius);
      margin-bottom: 10px;
      font-size: 1em;
      width: 100%;
    }
    input[type="file"] { cursor: pointer; }
    input[type="file"]::file-selector-button {
      background-color: var(--accent-color);
      color: white;
      border: none;
      padding: 8px 15px;
      border-radius: var(--border-radius);
      cursor: pointer;
      transition: background-color var(--transition-speed) ease;
      margin-right: 10px;
    }
    input[type="file"]::file-selector-button:hover { background-color: #0088cc; }
    /* === Password Overlay === */
    #password-overlay {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background-color: rgba(0, 0, 0, 0.9);
      display: flex; justify-content: center; align-items: center; z-index: 1000;
      opacity: 1; transition: opacity 0.5s ease;
    }
    #password-overlay.fade-out { opacity: 0; pointer-events: none; }
    .password-box {
      background-color: var(--secondary-bg);
      padding: 30px 40px;
      border-radius: var(--border-radius);
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
      text-align: center; max-width: 400px; width: 90%;
    }
    .password-box h2 { margin-bottom: 20px; color: var(--text-color); }
    .password-box p { color: var(--text-muted); margin-bottom: 15px; font-size: 0.9em; }
    /* === Main Application Layout === */
    #app-container {
      display: flex;
      flex-direction: column;
      height: 100vh;
      opacity: 0;
      transition: opacity 0.5s ease 0.5s;
    }
    #app-container.visible { opacity: 1; }
    /* Header */
    header {
      background-color: var(--secondary-bg);
      padding: 10px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-shrink: 0;
      box-shadow: 0 2px 10px rgba(0,0,0,0.3);
      z-index: 100;
    }
    header h1 { font-size: 1.5em; color: var(--accent-color); margin: 0; }
    .peer-info { font-size: 0.85em; color: var(--text-muted); text-align: right; }
    .peer-info span { display: block; margin-bottom: 2px; }
    #peer-id {
      font-weight: bold;
      color: var(--text-color);
      cursor: pointer;
      padding: 2px 4px;
      background-color: var(--tertiary-bg);
      border-radius: 4px;
      word-break: break-all;
    }
    #connection-status { font-weight: bold; }
    #connection-status.connected { color: var(--success-color); }
    #connection-status.disconnected { color: var(--error-color); }
    #connection-status.connecting { color: orange; }
    /* Main Content Area */
    main {
      display: flex;
      flex-grow: 1;
      overflow: hidden;
      position: relative;
    }
    /* Sidebar (File List & Upload) */
    #sidebar {
      width: 300px;
      background-color: var(--secondary-bg);
      padding: 20px;
      display: flex;
      flex-direction: column;
      overflow-y: auto;
      flex-shrink: 0;
      transition: width var(--transition-speed) ease;
      border-right: 1px solid var(--tertiary-bg);
    }
    #sidebar h2 {
      font-size: 1.2em;
      margin-bottom: 15px;
      color: var(--accent-color);
      border-bottom: 1px solid var(--tertiary-bg);
      padding-bottom: 10px;
    }
    /* File Upload Section */
    .upload-section {
      margin-bottom: 20px;
      padding-bottom: 20px;
      border-bottom: 1px solid var(--tertiary-bg);
    }
    #upload-progress {
      width: 100%;
      height: 8px;
      appearance: none;
      background-color: var(--tertiary-bg);
      border-radius: 4px;
      overflow: hidden;
      margin-top: 10px;
    }
    #upload-progress::-webkit-progress-bar { background-color: var(--tertiary-bg); }
    #upload-progress::-webkit-progress-value { background-color: var(--success-color); transition: width 0.1s linear; }
    #upload-progress::-moz-progress-bar { background-color: var(--success-color); transition: width 0.1s linear; }
    /* File List Section */
    .file-list-section {
      flex-grow: 1;
      overflow-y: auto;
      margin-bottom: 20px;
    }
    #file-list { list-style: none; padding: 0; margin: 0; }
    #file-list li {
      background-color: var(--tertiary-bg);
      padding: 10px 15px;
      margin-bottom: 8px;
      border-radius: var(--border-radius);
      cursor: pointer;
      transition: background-color var(--transition-speed) ease, transform var(--transition-speed) ease;
      display: flex;
      justify-content: space-between;
      align-items: center;
      word-break: break-word;
    }
    #file-list li:hover { background-color: #555566; transform: translateX(3px); }
    #file-list li.playing {
      background-color: var(--accent-color);
      color: white;
      font-weight: bold;
    }
    .file-name { flex-grow: 1; margin-right: 10px; }
    .file-actions button {
      background: none;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      font-size: 1.1em;
      padding: 5px;
      transition: color var(--transition-speed) ease;
    }
    .file-actions button:hover { color: var(--error-color); }
    #file-list li.playing .file-actions button { color: white; }
    #file-list li.playing .file-actions button:hover { color: #ffdddd; }
    #no-files-message {
      color: var(--text-muted);
      font-style: italic;
      text-align: center;
      margin-top: 20px;
    }
    /* Peer Connection Section */
    .peer-connection-section {
      margin-top: auto;
      padding-top: 20px;
      border-top: 1px solid var(--tertiary-bg);
    }
    .peer-connection-section input[type="text"] { margin-bottom: 10px; }
    /* Media Viewer Area */
    #media-viewer-container {
      flex-grow: 1;
      background-color: #000;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
      position: relative;
    }
    #media-placeholder {
      color: var(--text-muted);
      font-size: 1.5em;
      text-align: center;
      padding: 20px;
    }
    #media-viewer-container video,
    #media-viewer-container audio,
    #media-viewer-container img {
      max-width: 100%;
      max-height: 100%;
      display: block;
      object-fit: contain;
    }
    #media-viewer-container video,
    #media-viewer-container audio {
      width: 100%;
      outline: none;
    }
    /* === Responsive Design === */
    @media (max-width: 768px) {
      body { font-size: 14px; }
      main { flex-direction: column; }
      #sidebar {
        width: 100%;
        height: 40vh;
        max-height: 350px;
        border-right: none;
        border-bottom: 1px solid var(--tertiary-bg);
        flex-shrink: 0;
        overflow-y: auto;
      }
      .file-list-section { flex-grow: 1; min-height: 100px; }
      .peer-connection-section { margin-top: 10px; padding-top: 10px; }
      #media-viewer-container {
        flex-grow: 1;
        height: 60vh;
        min-height: 200px;
      }
      header { padding: 8px 15px; }
      header h1 { font-size: 1.2em; }
      .peer-info { font-size: 0.75em; }
      .password-box { padding: 20px 25px; }
      .button { padding: 8px 15px; font-size: 0.9em; }
      input[type="text"], input[type="password"], input[type="file"] { padding: 8px; font-size: 0.9em; }
      input[type="file"]::file-selector-button { padding: 6px 10px; }
      #file-list li { padding: 8px 12px; }
    }
    @media (max-width: 480px) {
      header {
        flex-direction: column;
        align-items: flex-start;
        padding-bottom: 10px;
      }
      .peer-info {
        text-align: left;
        margin-top: 5px;
        width: 100%;
      }
      #peer-id {
        display: inline-block;
        max-width: 80%;
        overflow: hidden;
        text-overflow: ellipsis;
        vertical-align: middle;
      }
    }
    /* === Animations & Transitions === */
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    .spinner {
      border: 3px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      border-top-color: var(--accent-color);
      width: 20px;
      height: 20px;
      animation: spin 1s linear infinite;
      display: inline-block;
      margin-left: 10px;
      vertical-align: middle;
    }
  </style>
</head>
<body>
  <!-- Password Protection Overlay -->
  <div id="password-overlay">
    <div class="password-box">
      <h2>Access Decentralized Hub</h2>
      <p>Enter the password to continue.</p>
      <input type="password" id="password-input" placeholder="Password" />
      <button id="password-submit" class="button">Unlock</button>
      <p id="password-error" class="error-message hidden">Incorrect password.</p>
    </div>
  </div>

  <!-- Main Application Container (hidden until password is correct) -->
  <div id="app-container" class="hidden">
    <header>
      <h1>Media Hub</h1>
      <div class="peer-info">
        <span>Your Peer ID: <strong id="peer-id" title="Click to copy">Loading...</strong>
          <span id="copy-feedback" class="success-message hidden" style="display: inline; margin-left: 5px;">Copied!</span>
        </span>
        <span>Status: <strong id="connection-status" class="disconnected">Disconnected</strong>
          <span id="peer-spinner" class="spinner hidden"></span>
        </span>
        <span>Connected Peers: <strong id="peer-count">0</strong></span>
      </div>
    </header>

    <main>
      <!-- Sidebar: Upload, File List, Peer Connection -->
      <aside id="sidebar">
        <!-- File Upload -->
        <section class="upload-section">
          <h2>Upload Media</h2>
          <input type="file" id="file-input" accept="video/*,audio/*,image/*" multiple />
          <progress id="upload-progress" value="0" max="100" class="hidden"></progress>
          <p id="upload-status" class="success-message hidden"></p>
          <p id="upload-error" class="error-message hidden"></p>
        </section>
        <!-- File List -->
        <section class="file-list-section">
          <h2>Local Files</h2>
          <ul id="file-list">
            <!-- File items will be added dynamically here -->
          </ul>
          <p id="no-files-message">No files uploaded yet. Upload files to get started!</p>
        </section>
        <!-- Peer Connection -->
        <section class="peer-connection-section">
          <h2>Connect to Peer</h2>
          <input type="text" id="peer-connect-id" placeholder="Enter Peer ID" />
          <button id="connect-button" class="button secondary">Connect</button>
          <p id="connect-status" style="font-size: 0.9em; margin-top: 5px;"></p>
        </section>
      </aside>
      <!-- Media Viewer -->
      <section id="media-viewer-container">
        <div id="media-placeholder">Select a file from the list to play</div>
      </section>
    </main>
  </div>

  <script>
    // === Configuration ===
    const CORRECT_PASSWORD = "password123";
    const DB_NAME = "decentralizedMediaDB";
    const DB_VERSION = 1;
    const FILE_STORE_NAME = "mediaFiles";

    // === Global State ===
    let db = null;
    let peer = null;
    let currentPeerId = null;
    let connections = {}; // Active PeerJS data connections: { peerId: connection }
    let isSyncingPlayback = false;
    let currentPlayingFileId = null;

    // === DOM Elements ===
    const passwordOverlay = document.getElementById('password-overlay');
    const passwordInput = document.getElementById('password-input');
    const passwordSubmit = document.getElementById('password-submit');
    const passwordError = document.getElementById('password-error');
    const appContainer = document.getElementById('app-container');
    const peerIdElement = document.getElementById('peer-id');
    const copyFeedbackElement = document.getElementById('copy-feedback');
    const connectionStatusElement = document.getElementById('connection-status');
    const peerSpinnerElement = document.getElementById('peer-spinner');
    const peerCountElement = document.getElementById('peer-count');
    const fileInput = document.getElementById('file-input');
    const uploadProgress = document.getElementById('upload-progress');
    const uploadStatus = document.getElementById('upload-status');
    const uploadError = document.getElementById('upload-error');
    const fileListElement = document.getElementById('file-list');
    const noFilesMessage = document.getElementById('no-files-message');
    const mediaViewerContainer = document.getElementById('media-viewer-container');
    const mediaPlaceholder = document.getElementById('media-placeholder');
    const peerConnectIdInput = document.getElementById('peer-connect-id');
    const connectButton = document.getElementById('connect-button');
    const connectStatus = document.getElementById('connect-status');

    // === Initialization ===
    document.addEventListener('DOMContentLoaded', () => {
      passwordInput.focus();
      passwordSubmit.addEventListener('click', handlePasswordSubmit);
      passwordInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') handlePasswordSubmit(); });
      fileInput.addEventListener('change', handleFileUpload);
      peerIdElement.addEventListener('click', copyPeerId);
      connectButton.addEventListener('click', connectToPeer);
      peerConnectIdInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') connectToPeer(); });
      fileListElement.addEventListener('click', handleFileListClick);
    });

    // === Password Protection ===
    function handlePasswordSubmit() {
      const enteredPassword = passwordInput.value;
      if (enteredPassword === CORRECT_PASSWORD) {
        passwordOverlay.classList.add('fade-out');
        appContainer.classList.remove('hidden');
        setTimeout(() => {
          appContainer.classList.add('visible');
          setTimeout(() => passwordOverlay.remove(), 500);
          initializeApp();
        }, 10);
      } else {
        passwordError.classList.remove('hidden');
        passwordInput.value = '';
        passwordInput.focus();
      }
    }

    // === Main App Initialization ===
    async function initializeApp() {
      console.log("Initializing application...");
      try {
        await setupIndexedDB();
        await loadFilesFromDB();
        initializePeerJS();
      } catch (error) {
        console.error("Initialization failed:", error);
        mediaPlaceholder.textContent = "Error initializing application. Please refresh.";
        mediaPlaceholder.style.color = 'var(--error-color)';
      }
    }

    // === IndexedDB Operations ===
    function setupIndexedDB() {
      return new Promise((resolve, reject) => {
        if (!window.indexedDB) {
          console.error("IndexedDB is not supported by this browser.");
          uploadError.textContent = "IndexedDB not supported. Cannot store files.";
          uploadError.classList.remove('hidden');
          return reject(new Error("IndexedDB not supported"));
        }
        const request = indexedDB.open(DB_NAME, DB_VERSION);
        request.onerror = (event) => {
          console.error("IndexedDB error:", event.target.error);
          reject(new Error(`IndexedDB error: ${event.target.error}`));
        };
        request.onsuccess = (event) => {
          db = event.target.result;
          console.log("IndexedDB setup complete.");
          resolve();
        };
        request.onupgradeneeded = (event) => {
          db = event.target.result;
          console.log("Upgrading IndexedDB...");
          if (!db.objectStoreNames.contains(FILE_STORE_NAME)) {
            const objectStore = db.createObjectStore(FILE_STORE_NAME, { keyPath: 'id', autoIncrement: true });
            objectStore.createIndex('name', 'name', { unique: false });
            console.log(`Object store "${FILE_STORE_NAME}" created.`);
          }
        };
      });
    }

    function storeFileInDB(file) {
      return new Promise((resolve, reject) => {
        if (!db) return reject(new Error("Database not initialized."));
        const transaction = db.transaction([FILE_STORE_NAME], 'readwrite');
        const store = transaction.objectStore(FILE_STORE_NAME);
        const fileRecord = { name: file.name, type: file.type, size: file.size, data: file };
        const request = store.add(fileRecord);
        request.onsuccess = (event) => {
          console.log(`File "${file.name}" stored successfully with ID: ${event.target.result}`);
          resolve(event.target.result);
        };
        request.onerror = (event) => {
          console.error(`Error storing file "${file.name}":`, event.target.error);
          reject(new Error(`Failed to store file: ${event.target.error}`));
        };
      });
    }

    function getFileFromDB(id) {
      return new Promise((resolve, reject) => {
        if (!db) return reject(new Error("Database not initialized."));
        const transaction = db.transaction([FILE_STORE_NAME], 'readonly');
        const store = transaction.objectStore(FILE_STORE_NAME);
        const request = store.get(id);
        request.onsuccess = (event) => {
          const record = event.target.result;
          if (record && record.data) {
            resolve(record.data);
          } else {
            reject(new Error(`File with ID ${id} not found.`));
          }
        };
        request.onerror = (event) => {
          console.error(`Error retrieving file with ID ${id}:`, event.target.error);
          reject(new Error(`Failed to retrieve file: ${event.target.error}`));
        };
      });
    }

    function deleteFileFromDB(id) {
      return new Promise((resolve, reject) => {
        if (!db) return reject(new Error("Database not initialized."));
        const transaction = db.transaction([FILE_STORE_NAME], 'readwrite');
        const store = transaction.objectStore(FILE_STORE_NAME);
        const request = store.delete(id);
        request.onsuccess = () => {
          console.log(`File with ID ${id} deleted successfully.`);
          resolve();
        };
        request.onerror = (event) => {
          console.error(`Error deleting file with ID ${id}:`, event.target.error);
          reject(new Error(`Failed to delete file: ${event.target.error}`));
        };
      });
    }

    function loadFilesFromDB() {
      return new Promise((resolve, reject) => {
        if (!db) return reject(new Error("Database not initialized."));
        fileListElement.innerHTML = '';
        const transaction = db.transaction([FILE_STORE_NAME], 'readonly');
        const store = transaction.objectStore(FILE_STORE_NAME);
        const cursorRequest = store.openCursor();
        let fileFound = false;
        cursorRequest.onsuccess = (event) => {
          const cursor = event.target.result;
          if (cursor) {
            fileFound = true;
            const fileInfo = { id: cursor.value.id, name: cursor.value.name, type: cursor.value.type };
            addFileToListUI(fileInfo);
            cursor.continue();
          } else {
            console.log("Finished loading files from DB.");
            noFilesMessage.classList.toggle('hidden', fileFound);
            resolve();
          }
        };
        cursorRequest.onerror = (event) => {
          console.error("Error loading files:", event.target.error);
          noFilesMessage.textContent = "Error loading files.";
          noFilesMessage.classList.remove('hidden');
          reject(new Error(`Failed to load files: ${event.target.error}`));
        };
      });
    }

    // === New Helper Functions for File Sync ===
    // Get all files (full records) from IndexedDB.
    function getAllFilesFromDB() {
      return new Promise((resolve, reject) => {
        if (!db) return reject(new Error("Database not initialized."));
        const transaction = db.transaction([FILE_STORE_NAME], 'readonly');
        const store = transaction.objectStore(FILE_STORE_NAME);
        let files = [];
        const cursorRequest = store.openCursor();
        cursorRequest.onsuccess = (event) => {
          const cursor = event.target.result;
          if (cursor) {
            files.push(cursor.value);
            cursor.continue();
          } else {
            resolve(files);
          }
        };
        cursorRequest.onerror = (event) => {
          reject(new Error(`Error reading files: ${event.target.error}`));
        };
      });
    }

    // Convert Blob to Base64 data URL.
    function blobToBase64(blob) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });
    }

    // Convert Base64 data URL back to Blob.
    function dataURLtoBlob(dataurl) {
      const arr = dataurl.split(',');
      const mime = arr[0].match(/:(.*?);/)[1];
      const bstr = atob(arr[1]);
      let n = bstr.length;
      const u8arr = new Uint8Array(n);
      while (n--) { u8arr[n] = bstr.charCodeAt(n); }
      return new Blob([u8arr], { type: mime });
    }

    // Store a received file (if it does not already exist) in IndexedDB.
    function storeReceivedFile(name, type, size, blob) {
      return new Promise((resolve, reject) => {
        if (!db) return reject(new Error("Database not initialized."));
        const transaction = db.transaction([FILE_STORE_NAME], 'readwrite');
        const store = transaction.objectStore(FILE_STORE_NAME);
        // Check if a file with the same name exists.
        const index = store.index('name');
        const getRequest = index.get(name);
        getRequest.onsuccess = (event) => {
          if (event.target.result) {
            console.log(`File "${name}" already exists. Skipping.`);
            resolve(null);
          } else {
            const fileRecord = { name, type, size, data: blob };
            const addRequest = store.add(fileRecord);
            addRequest.onsuccess = (event) => {
              console.log(`Received file "${name}" stored with ID ${event.target.result}`);
              addFileToListUI({ id: event.target.result, name, type });
              resolve(event.target.result);
            };
            addRequest.onerror = (event) => {
              console.error(`Error storing received file "${name}":`, event.target.error);
              reject(new Error(`Failed to store received file: ${event.target.error}`));
            };
          }
        };
        getRequest.onerror = (event) => {
          console.error(`Error checking file "${name}":`, event.target.error);
          reject(new Error(`Failed to check existence: ${event.target.error}`));
        };
      });
    }

    // When a connection is open, send all local files to the peer.
    async function syncLocalFiles(conn) {
      try {
        const files = await getAllFilesFromDB();
        let syncFiles = [];
        for (const file of files) {
          const base64Data = await blobToBase64(file.data);
          syncFiles.push({
            name: file.name,
            type: file.type,
            size: file.size,
            data: base64Data
          });
        }
        const message = { type: 'syncFiles', files: syncFiles };
        conn.send(JSON.stringify(message));
        console.log("Sent syncFiles message with", syncFiles.length, "files.");
      } catch (error) {
        console.error("Error syncing files:", error);
      }
    }

    // === File Handling ===
    async function handleFileUpload() {
      const files = fileInput.files;
      if (!files.length) return;
      uploadStatus.classList.add('hidden');
      uploadError.classList.add('hidden');
      uploadProgress.classList.remove('hidden');
      uploadProgress.value = 0;
      const totalFiles = files.length;
      let filesProcessed = 0;
      let filesFailed = 0;
      for (const file of files) {
        try {
          if (!file.type.match('video.*') && !file.type.match('audio.*') && !file.type.match('image.*')) {
            console.warn(`Skipping unsupported file type: ${file.name} (${file.type})`);
            filesFailed++;
            continue;
          }
          const fileId = await storeFileInDB(file);
          addFileToListUI({ id: fileId, name: file.name, type: file.type });
          noFilesMessage.classList.add('hidden');
        } catch (error) {
          console.error(`Failed to store file "${file.name}":`, error);
          filesFailed++;
        } finally {
          filesProcessed++;
          uploadProgress.value = (filesProcessed / totalFiles) * 100;
        }
      }
      uploadProgress.classList.add('hidden');
      if (filesFailed === 0) {
        uploadStatus.textContent = `${totalFiles} file(s) uploaded successfully.`;
        uploadStatus.classList.remove('hidden');
      } else {
        uploadError.textContent = `Processed ${totalFiles} file(s). ${filesProcessed - filesFailed} succeeded, ${filesFailed} failed.`;
        uploadError.classList.remove('hidden');
      }
      fileInput.value = '';
      setTimeout(() => {
        uploadStatus.classList.add('hidden');
        uploadError.classList.add('hidden');
      }, 5000);
    }

    function addFileToListUI(fileInfo) {
      const listItem = document.createElement('li');
      listItem.dataset.fileId = fileInfo.id;
      listItem.dataset.fileName = fileInfo.name;
      listItem.dataset.fileType = fileInfo.type;
      const nameSpan = document.createElement('span');
      nameSpan.classList.add('file-name');
      nameSpan.textContent = fileInfo.name;
      listItem.appendChild(nameSpan);
      const actionsSpan = document.createElement('span');
      actionsSpan.classList.add('file-actions');
      const deleteButton = document.createElement('button');
      deleteButton.innerHTML = '×';
      deleteButton.title = 'Delete File';
      deleteButton.dataset.action = 'delete';
      actionsSpan.appendChild(deleteButton);
      listItem.appendChild(actionsSpan);
      fileListElement.appendChild(listItem);
    }

    async function handleFileListClick(event) {
      const target = event.target;
      const listItem = target.closest('li[data-file-id]');
      if (!listItem) return;
      const fileId = parseInt(listItem.dataset.fileId, 10);
      if (target.dataset.action === 'delete') {
        event.stopPropagation();
        await deleteFile(fileId, listItem);
      } else {
        const fileInfo = { id: fileId, name: listItem.dataset.fileName, type: listItem.dataset.fileType };
        await playFile(fileInfo);
        broadcastMessage({ type: 'playFile', fileId: fileId, fileName: fileInfo.name, fileType: fileInfo.type });
        updatePlayingIndicator(fileId);
      }
    }

    async function deleteFile(fileId, listItem) {
      if (!confirm(`Are you sure you want to delete "${listItem.dataset.fileName}"?`)) return;
      try {
        await deleteFileFromDB(fileId);
        listItem.remove();
        console.log(`File ${fileId} removed from UI.`);
        if (currentPlayingFileId === fileId) {
          clearMediaViewer();
          currentPlayingFileId = null;
        }
        if (fileListElement.children.length === 0) {
          noFilesMessage.classList.remove('hidden');
        }
      } catch (error) {
        console.error(`Failed to delete file ${fileId}:`, error);
        alert(`Error deleting file: ${error.message}`);
      }
    }

    // === Media Playback ===
    async function playFile(fileInfo) {
      console.log(`Attempting to play file: ID=${fileInfo.id}, Name=${fileInfo.name}, Type=${fileInfo.type}`);
      clearMediaViewer(false);
      try {
        const fileBlob = await getFileFromDB(fileInfo.id);
        const mediaElement = setupMediaElement(fileInfo.type, fileBlob);
        if (mediaElement) {
          mediaViewerContainer.innerHTML = '';
          mediaViewerContainer.appendChild(mediaElement);
          mediaPlaceholder.classList.add('hidden');
          currentPlayingFileId = fileInfo.id;
          console.log(`Now playing: ${fileInfo.name}`);
          setupMediaSync(mediaElement);
          if (mediaElement.play) {
            mediaElement.play().catch(e => console.warn("Autoplay prevented:", e));
          }
        } else {
          console.warn(`Cannot display file type: ${fileInfo.type}`);
          mediaPlaceholder.textContent = `Cannot display file type: ${fileInfo.type}`;
          mediaPlaceholder.style.color = 'var(--error-color)';
          mediaPlaceholder.classList.remove('hidden');
          currentPlayingFileId = null;
        }
      } catch (error) {
        console.error(`Error playing file ID ${fileInfo.id}:`, error);
        mediaPlaceholder.textContent = `Error loading file "${fileInfo.name}". It might have been deleted or corrupted.`;
        mediaPlaceholder.style.color = 'var(--error-color)';
        mediaPlaceholder.classList.remove('hidden');
        currentPlayingFileId = null;
        updatePlayingIndicator(null);
      }
    }

    function setupMediaElement(fileType, fileBlob) {
      let mediaElement = null;
      const objectURL = URL.createObjectURL(fileBlob);
      if (fileType.startsWith('video/')) {
        mediaElement = document.createElement('video');
        mediaElement.controls = true;
        mediaElement.autoplay = true;
        mediaElement.src = objectURL;
      } else if (fileType.startsWith('audio/')) {
        mediaElement = document.createElement('audio');
        mediaElement.controls = true;
        mediaElement.autoplay = true;
        mediaElement.src = objectURL;
      } else if (fileType.startsWith('image/')) {
        mediaElement = document.createElement('img');
        mediaElement.src = objectURL;
        mediaElement.alt = "Image preview";
      }
      if (mediaElement) {
        const revoke = () => {
          URL.revokeObjectURL(objectURL);
          console.log("Revoked Object URL:", objectURL.substring(objectURL.length - 10));
          if (mediaElement.removeEventListener) {
            mediaElement.removeEventListener('load', revokeCheck);
            mediaElement.removeEventListener('error', revokeCheck);
            mediaElement.removeEventListener('loadeddata', revokeCheck);
          }
        };
        const revokeCheck = () => {};
        mediaElement.addEventListener('load', revokeCheck);
        mediaElement.addEventListener('error', revokeCheck);
        mediaElement.addEventListener('loadeddata', revokeCheck);
        mediaElement.dataset.objectUrl = objectURL;
      }
      return mediaElement;
    }

    function clearMediaViewer(showPlaceholder = true) {
      const existingMedia = mediaViewerContainer.querySelector('video, audio, img');
      if (existingMedia && existingMedia.dataset.objectUrl) {
        URL.revokeObjectURL(existingMedia.dataset.objectUrl);
        console.log("Revoked Object URL on clear:", existingMedia.dataset.objectUrl.substring(existingMedia.dataset.objectUrl.length - 10));
      }
      mediaViewerContainer.innerHTML = '';
      if (showPlaceholder) {
        mediaViewerContainer.appendChild(mediaPlaceholder);
        mediaPlaceholder.textContent = "Select a file from the list to play";
        mediaPlaceholder.style.color = 'var(--text-muted)';
        mediaPlaceholder.classList.remove('hidden');
      } else {
        mediaPlaceholder.classList.add('hidden');
      }
    }

    function setupMediaSync(mediaElement) {
      if (!(mediaElement instanceof HTMLMediaElement)) return;
      const broadcastPlaybackState = (action, time = null) => {
        if (!isSyncingPlayback) {
          console.log(`Broadcasting playback: ${action} at ${time === null ? 'current time' : time.toFixed(2)}`);
          const message = {
            type: 'playback',
            action: action,
            time: time === null ? mediaElement.currentTime : time
          };
          broadcastMessage(message);
        }
      };
      mediaElement.onplay = () => broadcastPlaybackState('play');
      mediaElement.onpause = () => broadcastPlaybackState('pause');
      mediaElement.onseeked = () => broadcastPlaybackState('seek', mediaElement.currentTime);
    }

    function updatePlayingIndicator(playingFileId) {
      document.querySelectorAll('#file-list li').forEach(item => {
        const itemId = parseInt(item.dataset.fileId, 10);
        item.classList.toggle('playing', itemId === playingFileId);
      });
      currentPlayingFileId = playingFileId;
    }

    // === PeerJS WebRTC Handling ===
    function initializePeerJS() {
      console.log("Initializing PeerJS...");
      peerSpinnerElement.classList.remove('hidden');
      connectionStatusElement.textContent = "Initializing...";
      connectionStatusElement.className = 'connecting';
      peer = new Peer(undefined, {});
      peer.on('open', (id) => {
        currentPeerId = id;
        console.log('PeerJS initialized. My Peer ID is:', id);
        peerIdElement.textContent = id;
        peerIdElement.title = 'Click to copy';
        connectionStatusElement.textContent = "Waiting";
        connectionStatusElement.className = 'disconnected';
        peerSpinnerElement.classList.add('hidden');
      });
      peer.on('connection', (conn) => {
        console.log(`Incoming connection from: ${conn.peer}`);
        setupConnection(conn);
      });
      peer.on('disconnected', () => {
        console.warn('PeerJS disconnected from signaling server. Attempting to reconnect...');
        connectionStatusElement.textContent = "Reconnecting...";
        connectionStatusElement.className = 'connecting';
        peerSpinnerElement.classList.remove('hidden');
      });
      peer.on('close', () => {
        console.error('PeerJS connection closed permanently.');
        connectionStatusElement.textContent = "Closed";
        connectionStatusElement.className = 'disconnected';
        peerSpinnerElement.classList.add('hidden');
        connections = {};
        updatePeerCount();
      });
      peer.on('error', (err) => {
        console.error('PeerJS error:', err);
        connectionStatusElement.textContent = `Error (${err.type})`;
        connectionStatusElement.className = 'disconnected';
        peerSpinnerElement.classList.add('hidden');
        if (err.type === 'peer-unavailable') {
          connectStatus.textContent = `Peer ${peerConnectIdInput.value} not found.`;
          connectStatus.style.color = 'var(--error-color)';
        } else if (err.type === 'network') {
          connectStatus.textContent = `Network error. Check connection.`;
          connectStatus.style.color = 'var(--error-color)';
        } else {
          connectStatus.textContent = `Connection error: ${err.type}`;
          connectStatus.style.color = 'var(--error-color)';
        }
        setTimeout(() => { connectStatus.textContent = ''; }, 5000);
      });
    }

    function setupConnection(conn) {
      if (connections[conn.peer]) {
        console.warn(`Already connected to ${conn.peer}. Rejecting duplicate.`);
        conn.close();
        return;
      }
      conn.on('open', () => {
        console.log(`Connection established with: ${conn.peer}`);
        connections[conn.peer] = conn;
        updatePeerCount();
        updateConnectionStatus();
        connectStatus.textContent = `Connected to ${conn.peer}`;
        connectStatus.style.color = 'var(--success-color)';
        peerConnectIdInput.value = '';
        // Send local files to the new peer
        syncLocalFiles(conn);
      });
      conn.on('data', (data) => {
        console.log(`Data received from ${conn.peer}:`, data);
        handleIncomingMessage(data, conn.peer);
      });
      conn.on('close', () => {
        console.log(`Connection closed with: ${conn.peer}`);
        delete connections[conn.peer];
        updatePeerCount();
        updateConnectionStatus();
      });
      conn.on('error', (err) => {
        console.error(`Connection error with ${conn.peer}:`, err);
        delete connections[conn.peer];
        updatePeerCount();
        updateConnectionStatus();
        connectStatus.textContent = `Error with ${conn.peer}: ${err.message}`;
        connectStatus.style.color = 'var(--error-color)';
      });
    }

    function connectToPeer() {
      const remotePeerId = peerConnectIdInput.value.trim();
      if (!remotePeerId) {
        connectStatus.textContent = 'Please enter a Peer ID.';
        connectStatus.style.color = 'var(--error-color)';
        return;
      }
      if (!peer || peer.destroyed) {
        connectStatus.textContent = 'PeerJS not initialized or destroyed.';
        connectStatus.style.color = 'var(--error-color)';
        return;
      }
      if (remotePeerId === currentPeerId) {
        connectStatus.textContent = 'Cannot connect to yourself.';
        connectStatus.style.color = 'var(--error-color)';
        return;
      }
      if (connections[remotePeerId]) {
        connectStatus.textContent = `Already connected to ${remotePeerId}.`;
        connectStatus.style.color = 'var(--text-muted)';
        return;
      }
      console.log(`Attempting to connect to peer: ${remotePeerId}`);
      connectStatus.textContent = `Connecting to ${remotePeerId}...`;
      connectStatus.style.color = 'var(--text-muted)';
      try {
        const conn = peer.connect(remotePeerId, { reliable: true });
        setupConnection(conn);
      } catch (error) {
        console.error("Error initiating connection:", error);
        connectStatus.textContent = `Failed to initiate connection: ${error.message}`;
        connectStatus.style.color = 'var(--error-color)';
      }
    }

    function broadcastMessage(message) {
      if (Object.keys(connections).length === 0) return;
      console.log("Broadcasting message:", message);
      const messageString = JSON.stringify(message);
      for (const peerId in connections) {
        const conn = connections[peerId];
        if (conn && conn.open) {
          try {
            conn.send(messageString);
          } catch (error) {
            console.error(`Failed to send message to ${peerId}:`, error);
          }
        } else {
          console.warn(`Attempted to send message to non-open connection: ${peerId}`);
        }
      }
    }

    async function handleIncomingMessage(data, senderId) {
      let message;
      try {
        message = (typeof data === 'string') ? JSON.parse(data) : data;
        if (typeof message !== 'object' || message === null) throw new Error("Invalid message format");
      } catch (error) {
        console.error(`Failed to parse message from ${senderId}:`, error, "Data:", data);
        return;
      }
      console.log(`Processing message type "${message.type}" from ${senderId}`);
      switch (message.type) {
        case 'playFile':
          console.log(`Peer ${senderId} requested playback of file ID: ${message.fileId}, Name: ${message.fileName}`);
          const fileInfo = { id: message.fileId, name: message.fileName, type: message.fileType };
          await playFile(fileInfo);
          updatePlayingIndicator(message.fileId);
          break;
        case 'playback':
          console.log(`Peer ${senderId} sent playback command: ${message.action} at time ${message.time}`);
          syncPlaybackState(message.action, message.time);
          break;
        case 'requestState':
          console.log(`Peer ${senderId} requested current state.`);
          if (currentPlayingFileId !== null) {
            const playingItem = document.querySelector(`#file-list li[data-file-id="${currentPlayingFileId}"]`);
            if (playingItem) {
              const response = {
                type: 'playFile',
                fileId: currentPlayingFileId,
                fileName: playingItem.dataset.fileName,
                fileType: playingItem.dataset.fileType
              };
              if (connections[senderId] && connections[senderId].open) {
                connections[senderId].send(JSON.stringify(response));
                console.log("Sent current playback state to requester:", response);
                const mediaElement = mediaViewerContainer.querySelector('video, audio');
                if (mediaElement) {
                  const playbackMsg = {
                    type: 'playback',
                    action: mediaElement.paused ? 'pause' : 'play',
                    time: mediaElement.currentTime
                  };
                  connections[senderId].send(JSON.stringify(playbackMsg));
                  console.log("Sent current playback time/state to requester:", playbackMsg);
                }
              }
            }
          } else {
            console.log("Nothing currently playing to report state.");
          }
          break;
        case 'syncFiles':
          if (message.files && Array.isArray(message.files)) {
            console.log("Received syncFiles message with", message.files.length, "files.");
            for (const file of message.files) {
              const blob = dataURLtoBlob(file.data);
              await storeReceivedFile(file.name, file.type, file.size, blob);
            }
          }
          break;
        default:
          console.warn(`Received unknown message type "${message.type}" from ${senderId}`);
      }
    }

    function syncPlaybackState(action, time) {
      const mediaElement = mediaViewerContainer.querySelector('video, audio');
      if (!mediaElement) {
        console.warn("Cannot sync playback: No media element found.");
        return;
      }
      isSyncingPlayback = true;
      try {
        switch (action) {
          case 'play':
            if (mediaElement.paused) {
              console.log(`Sync: Playing media.`);
              if (Math.abs(mediaElement.currentTime - time) > 1.0) {
                console.log(`Sync: Seeking to ${time.toFixed(2)} before playing.`);
                mediaElement.currentTime = time;
              }
              mediaElement.play().catch(e => console.warn("Sync: Playback failed:", e));
            } else {
              if (Math.abs(mediaElement.currentTime - time) > 1.0) {
                console.log(`Sync: Adjusting time while playing to ${time.toFixed(2)}.`);
                mediaElement.currentTime = time;
              }
            }
            break;
          case 'pause':
            if (!mediaElement.paused) {
              console.log(`Sync: Pausing media.`);
              mediaElement.pause();
            }
            if (Math.abs(mediaElement.currentTime - time) > 0.2) {
              console.log(`Sync: Setting paused time to ${time.toFixed(2)}.`);
              mediaElement.currentTime = time;
            }
            break;
          case 'seek':
            if (Math.abs(mediaElement.currentTime - time) > 1.0) {
              console.log(`Sync: Seeking to ${time.toFixed(2)}.`);
              mediaElement.currentTime = time;
            } else {
              console.log(`Sync: Seek command received for ${time.toFixed(2)}, but current time ${mediaElement.currentTime.toFixed(2)} is close enough. Ignoring.`);
            }
            break;
        }
      } catch (error) {
        console.error("Error applying synced playback state:", error);
      } finally {
        setTimeout(() => { isSyncingPlayback = false; }, 100);
      }
    }

    function updatePeerCount() {
      const count = Object.keys(connections).length;
      peerCountElement.textContent = count;
    }

    function updateConnectionStatus() {
      const count = Object.keys(connections).length;
      if (count > 0) {
        connectionStatusElement.textContent = `Connected (${count})`;
        connectionStatusElement.className = 'connected';
      } else if (peer && !peer.disconnected) {
        connectionStatusElement.textContent = "Waiting";
        connectionStatusElement.className = 'disconnected';
      }
      peerSpinnerElement.classList.add('hidden');
    }

    function copyPeerId() {
      if (!currentPeerId) return;
      navigator.clipboard.writeText(currentPeerId).then(() => {
        console.log('Peer ID copied to clipboard');
        copyFeedbackElement.classList.remove('hidden');
        setTimeout(() => { copyFeedbackElement.classList.add('hidden'); }, 1500);
      }).catch(err => {
        console.error('Failed to copy Peer ID: ', err);
        alert(`Could not copy ID automatically. Your ID is: ${currentPeerId}`);
      });
    }
  </script>
</body>
</html>
